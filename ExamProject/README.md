# Екзамен
Основи об’єктно-орієнтованого програмування

Використовуючи принципи ООП, патерни проектування та методи мультипоточного програмування, реалізувати застосунок для демонстрації базових алгоритмів та структур даних.
 
Реалізувати демонстраційні сутності з певної предметної області
 (Посадові особи: міністерство, організація, підрозділ, співробітник)

Реалізувати наступні базові алгоритми та структури даних: 
•	Зв’язний список (Двозв’язний циклічний список). У вузлах списку можуть зберігатись як окремі елементи, так і інші контейнери.
•	Балансоване дерево пошуку (Red-black tree, B tree). У вузлах дерева можуть зберігатись як окремі елементи, так і інші контейнери (наприклад, розподіл за полями ключа). Ключем пошуку можуть бути повні сутності, а також окремі поля.
•	Хеш-таблиця на основі Separate Chaining (з можливістю використання довільної структури для вирішення колізій), а також один з варіантів Open Addressing
(Cuckoo hashing). В обох випадках передбачити можливість опціонального використання 2-choice hashing.
•	Алгоритми сортування 
(Insertion Sort, Quicksort, Merge Sort, Counting Sort). Ключем сортування можуть бути повні сутності, а також окремі поля.
•	Використати бібліотечні структури даних (наприклад, std::vector, std::list, std::map, std::unordered_map, чи відповідні аналоги з інших мов програмування), а також бібліотечні алгоритми сортування.
На основі реалізованих та використаних алгоритмів та структур даних реалізувати наступну функціональність:
1.	Контейнер «ключ-значення». Реалізувати операції отримання значення за ключем, зміни значення за ключем, додавання значення за ключем, видалення значення за ключем, отримання списку всіх ключів, отримання списку всіх значень, отримання списку всіх пар ключ-значення. Ключами можуть бути примітивні типи, а також реалізовані сутності предметної області чи їх окремі поля. Реалізації на основі хеш-таблиць, балансованих дерев пошуку, впорядкованих списків.
2.	Множина. Реалізувати операції перевірки належності елемента множині, додавання елемента, вилучення елемента, операції над множинами – об’єднання, перетин, різниця, симетрична різниця. Елементами множини можуть бути примітивні типи, а також реалізовані сутності предметної області чи їх окремі поля. Реалізації на основі хеш-таблиць, балансованих дерев пошуку, впорядкованих списків.
3.	Сортування. Реалізувати операції додавання елемента до контейнера, сортування контейнера за заданим критерієм, отримання заданої кількості елементів з 1) початку, 2) кінця, 3) середини, 4) заданої відносної позиції відсортованого списку (номер позиції або відсотки). Реалізації на основі списків та балансованих дерев пошуку.
Реалізувати можливість задавати значення вручну, а також генерації заданої кількості випадкових сутностей для перевірки роботи алгоритмів та структур даних.
Реалізувати можливості виміру часу виконання операцій на заданих вхідних даних.
Реалізувати графічний інтерфейс користувача (наприклад, з використанням Qt). Графічний інтерфейс має давати можливість вибору алгоритмів та структур даних, запуску операцій, перегляду результатів та результатів виміру часу роботи. 
Реалізувати можливість запуску алгоритмів на окремих потоках, при цьому потік GUI продовжує реагувати на події користувача. Також можна реалізувати паралельні версії алгоритмів, і отримати за це додаткові бали.
Реалізувати unit tests для перевірки роботи реалізованих алгоритмів та структур даних.
Під час реалізації необхідно дотримуватись принципів ООП, зокрема уникати дублювання коду, уникати сильної зв’язаності між різними компонентами, передбачити можливість розширення реалізованої функціональності.
Бажано продемонструвати використання патернів проектування, наприклад:
1.	Патерн Strategy – варто використати для реалізації алгоритмів, з можливістю заміни реалізації без зміни клієнтського коду
2.	Патерн Template Method – наприклад, реалізація одних операцій над множинами на основі інших
3.	Патерн Composite – можливість комбінувати структури даних: у вузлах заданої структури даних зберігаються інші структури даних.
4.	Патерн Decorator – можливість виміру часу виконання заданого алгоритму чи фрагменту алгоритму.
5.	Патерн Iterator – варто використати для обходу структур даних.
6.	Патерн Adapter – варто використати з метою використання бібліотечних реалізацій алгоритмів (зі стандартної бібліотеки або сторонніх бібліотек)
7.	Патерн Abstract Factory / Factory Method – варто використати для побудови стандартних реалізацій певних алгоритмів (залежно від налаштувань)
8.	Патерн Builder – варто використати для побудови складних структур даних чи алгоритмів
9.	Патерн Singleton – варто використати для підтримки класів, які мають існувати в одному екземплярі і бути доступними іншим класам (наприклад, класи для побудови алгоритмів)
10.	Патерн Visitor – варто використати для обробки складних структур даних, наприклад реалізації зберігання, операцій з множинами, …
11.	Патерн Bridge – варто використати для створення кількох версій інтерфейсу алгоритму чи структури даних, і незалежного розвитку їх реалізацій
12.	Патерн Command – варто використати для реалізації історії операцій над заданими структурами даних, з можливістю undo/redo
13.	Патерн Memento – варто використати для збереження та відновлення стану алгоритмів та структур даних (можливість завершити програму посередині виконання і потім відновитись з тої ж позиції)
14.	Патерн Façade – варто використати для загального інтерфейсу компонентів та взаємодії компонентів між собою.
 
